{"version":3,"file":"static/js/665.aef4c76f.chunk.js","mappings":"2OA8BA,EAxBMA,SAAAA,IAAAA,EAAAA,EAAAA,GAAAA,EAAAA,GAAAA,IAAAA,GAAAA,EAAAA,EAAAA,GAAAA,GACJ,WAAaC,GAAQ,IAAD,yBAClB,cAAMA,IACDC,KAAOD,EAAMC,KAClB,EAAKC,SAAWF,EAAME,SAHJ,EAoBnB,OAhBA,yCAED,WACEC,IAAAA,iBACD,oBAED,WACE,OACQ,gBAAKC,UAAU,aAAf,UACI,gBAAKA,UAAW,yCAAhB,UACI,iBAAMA,UAAS,mBAAcC,KAAKH,UAAlC,SACKG,KAAKJ,eAK3B,EArBGF,CAAoBO,EAAAA,Y,mKCoBpBC,EAAa,6/BAEnB,EAtBqB,WACnB,OACM,iCACA,6CACA,0FACU,cAAGC,KAAK,qCAAR,kBADV,4HAGE,cAAGA,KAAK,uEAAR,qCAHF,6EAKA,kBAAOC,IAAKC,EAAaC,SAAS,WAClCP,UAAU,kDADV,8DAEA,sIACA,8LAGA,SAACL,EAAA,EAAD,CAAaG,SAAS,IAAGD,KAAMM,S","sources":["components/CodeSnippet/CodeSnippet.js","pages/projects/bezier.js"],"sourcesContent":["import React from 'react'\nimport Prism from 'prismjs'\nimport './prismDark.css'\nimport 'prismjs/components/prism-python'\nimport 'prismjs/components/prism-c'\n\nclass CodeSnippet extends React.Component {\n  constructor (props) {\n    super(props)\n    this.code = props.code\n    this.language = props.language\n  }\n\n  componentDidMount () {\n    Prism.highlightAll()\n  }\n\n  render () {\n    return (\n            <div className=\"max-w-full\">\n                <pre className={'rounded-md border-amber-500 border-b-2'}>\n                    <code className={`language-${this.language}`}>\n                        {this.code}\n                    </code>\n                </pre>\n            </div>\n    )\n  }\n};\n\nexport default CodeSnippet\n","import React from 'react'\nimport '../Pages.css'\nimport CodeSnippet from '../../components/CodeSnippet/CodeSnippet'\n\nimport bezierVideo from '../../images/bezierVideo.mp4'\n\nconst BezierCurves = () => {\n  return (\n        <>\n        <h1>Bézier Curve</h1>\n        <p>In this project, I implemented my own curve object\n        to extend <a href='https://www.sfml-dev.org/index.php'>SFML</a>. The class takes in given points and a tension\n        to construct the corresponding curve. The program technically creates\n        a <a href='https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline'>Catmull–Rom spline</a> which\n        I chose because of its more efficient recursive implementation.</p>\n        <video src={bezierVideo} controls=\"controls\"\n        className='border-amber-500 rounded-md border-b-2 max-w-80'>Your browser does not support the video player.</video>\n        <p>The video above shows a demo of a curve object in a live editor window I built to help debug the program.</p>\n        <p>The code below shows the main section of my recursive implementation. The nodes are saved in a circular\n            linked list that allows new points to be inserted easily.\n        </p>\n        <CodeSnippet language=\"c\"code={bezierCode}/>\n        </>\n  )\n}\n\nconst bezierCode = 'void smooth_curve(Node* node1, sf::Vector2f eq[4], float flatnessFactor){\\n    Node* node2 = node1->next;\\n    Node* node3 = node2->next;\\n    \\n    if(is_flat(node1->point,node2->point,node3->point, flatnessFactor)) return;\\n    else{\\n        //creates new  points\\n        Node* add1 = new Node;\\n        Node* add2 = new Node;\\n        //assigned t value to points\\n        add1->t = (node1->t + node2->t) / 2;\\n        add2->t = (node2->t + node3->t) / 2;\\n        //calculates point value\\n        add1->point = eq[0] * add1->t * add1->t * add1->t + eq[1] * add1->t * add1->t + eq[2] * add1->t + eq[3];\\n        add2->point = eq[0] * add2->t * add2->t * add2->t + eq[1] * add2->t * add2->t + eq[2] * add2->t + eq[3];\\n        //appends new points to linked list\\n        add1->next = node2;\\n        node1->next = add1;\\n        add2->next = node3;\\n        node2->next = add2;\\n        //rinse and repeat\\n        smooth_curve(node1, eq, flatnessFactor);\\n        smooth_curve(node2, eq, flatnessFactor);\\n    }'\n\nexport default BezierCurves\n"],"names":["CodeSnippet","props","code","language","Prism","className","this","React","bezierCode","href","src","bezierVideo","controls"],"sourceRoot":""}